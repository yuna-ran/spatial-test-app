import { SpatialAudioExtension, } from "./index.esm.js";

AgoraRTC.setLogLevel(1);

const extension = new SpatialAudioExtension();
AgoraRTC.registerExtensions([extension]);

var options = {
  appid: null,
  channel: null,
  uid: null,
  token: null
};
var client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
var localUserTrack = {
  videoTrack: null,
  audioTrack: null
};

var localTrackState = {
  videoTrackMuted: false,
  audioTrackMuted: false
};


var remoteUsers = [];
var remoteUsersSound = [
  // './resources/1.mp3',
 //  './resources/2.mp3',
 // './resources/3.mp3',
  // './resources/4.mp3',
];

var localPlayerSound = [
  // './resources/1.mp3',
//  './resources/2.mp3',
//  // './resources/4.mp3',
];
//var localPlayTracks = [];
//var localPlayProcessors = [];
const processors = new Map();


// async function localPlayerStart() {
//   for (let i = 0; i < localPlayerSound.length; i++) {
//     setTimeout(async () => {
//       try {
//         const track = await AgoraRTC.createBufferSourceAudioTrack({ source: localPlayerSound[i] });
//      //   localPlayTracks.push(track);
//         track.startProcessAudioBuffer({ loop: true });
//         const processor = extension.createProcessor();
//         localPlayProcessors.push(processor);
//         track.pipe(processor).pipe(track.processorDestination);
//         track.play();
//       } catch (error) {
//         console.error(`localPlayerSound[${i}] with buffersource track ${localPlayerSound[i]} play fail: ${error}`);
//       }
//     }, 500 * i);
//   }
// }
// function localPlayerStop() {
//   for (let i = 0; i < localPlayerSound.length; i++) {
//     localPlayTracks[i].stop();
//   }
//   localPlayTracks = [];
// }

const mockLocalUserNewPosition = {
    // In a production app, the position can be generated by 
    // dragging the local user's avatar in a 3D scene.
    position: [1, 1, 1], // Coordinates in the world coordinate system
    forward: [1, 0, 0], // The unit vector of the front axis
    right: [0, 1, 0], // The unit vector of the right axis
    up: [0, 0, 1], // The unit vector of the vertical axis
};

extension.updateSelfPosition(
    mockLocalUserNewPosition.position,
    mockLocalUserNewPosition.forward,
    mockLocalUserNewPosition.right,
    mockLocalUserNewPosition.up
);



$("#join-form").submit(async function (e) {
  e.preventDefault();
  localUserTrack.audioTrack = await AgoraRTC.createMicrophoneAudioTrack();
  $("#join").attr("disabled", true);
  try {
    options.appid = $("#appid").val();
    options.token = $("#token").val();
    options.channel = $("#channel").val();
    await join();
    await client.publish(localUserTrack.audioTrack);
    if (options.token) {
      $("#success-alert-with-token").css("display", "block");
    } else {
      $("#success-alert a").attr("href", `index.html?appid=${options.appid}&channel=${options.channel}&token=${options.token}`);
      $("#success-alert").css("display", "block");
    }
  } catch (error) {
    console.error(error);
  } finally {
    $("#leave").attr("disabled", false);
    $("#mute-self").attr("disabled", false);
    $("#mute-peer").attr("disabled", false);
  }
})



$("#leave").click(function (e) {
  leave();
})
$("#mute-self").click(function (e) {
  if (!localTrackState.audioTrackMuted) {
   muteAudio();
  } else {
    unmuteAudio();
  }
  //  $("#mute-audio").text("Unmute Audio");
  //await localUserTrack.audioTrack.setMuted(true);
})

async function muteAudio() {
 await localUserTrack.audioTrack.setMuted(true);
    localTrackState.audioTrackMuted = true;
    $("#mute-self").text("Unmute Audio");
}
async function unmuteAudio() {
  await localUserTrack.audioTrack.setMuted(false);
    localTrackState.audioTrackMuted = false;
    $("#mute-self").text("Mute Audio");
}

async function join() {
  client.on("user-published", handleUserPublished);
  client.on("user-unpublished", handleUserUnpublished);

  [options.uid,] = await Promise.all([
    client.join(options.appid, options.channel, options.token || null),
  ]);
}
async function leave() {
  for (const trackName in localUserTrack) {
    var track = localUserTrack[trackName];
    if (track) {
      track.stop();
      track.close();
      localUserTrack[trackName] = undefined;
    }
  }
  remoteUsers = [];
  $("#remote-playerlist").html("");
  await client.leave();

  $("#local-player-name").text("");
  $("#join").attr("disabled", false);
  $("#leave").attr("disabled", true);
  console.log("client leaves channel success");
}

async function subscribe(user, mediaType) {
  const uid = user.uid;
  await client.subscribe(user, mediaType);
  console.log("subscribe success");
  if (mediaType === 'video') {
    const player = $(`
      <div id="player-wrapper-${uid}">
        <p class="player-name">remoteUser(${uid})</p>
        <div id="player-${uid}" class="player"></div>
      </div>
    `);
    $("#remote-playerlist").append(player);
    user.videoTrack.play(`player-${uid}`);
  }
  if (mediaType === 'audio') {
    const processor = extension.createProcessor();
    processors.set(user.uid, processor);

    const track = user.audioTrack;
    track.pipe(processor).pipe(track.processorDestination);
    track.play();
  }
}

function handleUserPublished(user, mediaType) {
  const id = user.uid;
  remoteUsers.push(user);
  subscribe(user, mediaType);
}

function handleUserUnpublished(user) {
  const id = user.uid;
  $(`#player-wrapper-${id}`).remove();
}

const positionSlider = document.getElementById("azimuth");
const positionOutput = document.getElementById("azimuthValue");
positionSlider.oninput = function () {
  positionOutput.innerHTML = this.value;
  remoteUsers.forEach(e => {
   // e.processor.updateSpatialAzimuth(this.value);
   console.log("now processing uid " + e.uid + " with value " + this.value);
   const processor = processors.get(e.uid);
   processor.updateRemotePosition({
        position: [this.value, 0, 0],
        forward: [1, 0, 0],
        });
  });

}


